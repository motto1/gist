name: Release

on:
  workflow_dispatch:
    inputs:
      bump:
        description: 'Version bump type (auto|patch|minor|major)'
        required: false
        default: 'auto'
        type: choice
        options:
          - auto
          - patch
          - minor
          - major
  push:
    branches:
      - main
      - master

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: true

jobs:
  prepare:
    if: ${{ github.event_name != 'push' || !contains(github.event.head_commit.message || '', '[skip ci]') }}
    runs-on: ubuntu-latest
    outputs:
      base: ${{ steps.version.outputs.base }}
      bump: ${{ steps.version.outputs.bump }}
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Resolve release version
        id: version
        shell: bash
        run: |
          set -euo pipefail

          INPUT_BUMP="${{ github.event.inputs.bump }}"
          if [ -z "${INPUT_BUMP}" ]; then
            INPUT_BUMP="auto"
          fi

          LAST_TAG=$(git tag --list "v[0-9]*.[0-9]*.[0-9]*" --sort=-v:refname | head -n1 || true)
          if [ -n "${LAST_TAG}" ]; then
            BASE_VERSION="${LAST_TAG#v}"
            RANGE="${LAST_TAG}..HEAD"
          else
            BASE_VERSION=$(node -p "require('./package.json').version")
            RANGE="HEAD"
          fi

          COMMIT_MESSAGES=$(git log --format=%B ${RANGE} || true)

          BUMP="${INPUT_BUMP}"
          if [ "${BUMP}" = "auto" ]; then
            BUMP="patch"
            if printf "%s\n" "${COMMIT_MESSAGES}" | grep -Eqi 'BREAKING CHANGE|^[a-z]+(\([^)]+\))?!:'; then
              BUMP="major"
            elif printf "%s\n" "${COMMIT_MESSAGES}" | grep -Eq '^feat(\([^)]+\))?:'; then
              BUMP="minor"
            fi
          fi

          NEXT_VERSION=$(BASE_VERSION="${BASE_VERSION}" BUMP="${BUMP}" node <<'NODE'
          const base = process.env.BASE_VERSION || '0.0.0'
          const bump = process.env.BUMP || 'patch'
          const [major0, minor0, patch0] = base
            .split('-')[0]
            .split('.')
            .map((x) => Number.parseInt(x, 10))

          let major = Number.isFinite(major0) ? major0 : 0
          let minor = Number.isFinite(minor0) ? minor0 : 0
          let patch = Number.isFinite(patch0) ? patch0 : 0

          if (bump === 'major') {
            major += 1
            minor = 0
            patch = 0
          } else if (bump === 'minor') {
            minor += 1
            patch = 0
          } else {
            patch += 1
          }

          process.stdout.write(`${major}.${minor}.${patch}`)
          NODE
          )

          echo "base=${BASE_VERSION}" >> "$GITHUB_OUTPUT"
          echo "bump=${BUMP}" >> "$GITHUB_OUTPUT"
          echo "version=${NEXT_VERSION}" >> "$GITHUB_OUTPUT"
          echo "tag=v${NEXT_VERSION}" >> "$GITHUB_OUTPUT"

          echo "Resolved release: base=${BASE_VERSION}, bump=${BUMP}, next=${NEXT_VERSION}"

  package-windows:
    needs: prepare
    runs-on: windows-latest
    timeout-minutes: 150
    strategy:
      fail-fast: false
      matrix:
        include:
          - edition: pro
            voice: full
          - edition: basic
            voice: none

    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      NODE_OPTIONS: --max-old-space-size=8192

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v5

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install corepack
        run: corepack enable && corepack prepare yarn@4.9.1 --activate

      - name: Set package.json version
        shell: bash
        run: |
          npm version "${{ needs.prepare.outputs.version }}" --no-git-tag-version --allow-same-version

      - name: Resolve cache paths
        id: cache-paths
        shell: pwsh
        run: |
          "yarn_cache=$(yarn config get cacheFolder)" >> $env:GITHUB_OUTPUT
          "electron_cache=$env:LOCALAPPDATA\electron\Cache" >> $env:GITHUB_OUTPUT
          "electron_builder_cache=$env:LOCALAPPDATA\electron-builder\Cache" >> $env:GITHUB_OUTPUT
          "node_gyp_cache=$env:LOCALAPPDATA\node-gyp\Cache" >> $env:GITHUB_OUTPUT

      - name: Cache yarn dependencies and native cache
        uses: actions/cache@v4
        with:
          path: |
            ${{ steps.cache-paths.outputs.yarn_cache }}
            node_modules
            ${{ steps.cache-paths.outputs.node_gyp_cache }}
          key: ${{ runner.os }}-node20-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-node20-yarn-

      - name: Cache electron binaries
        uses: actions/cache@v4
        with:
          path: |
            ${{ steps.cache-paths.outputs.electron_cache }}
            ${{ steps.cache-paths.outputs.electron_builder_cache }}
          key: ${{ runner.os }}-node20-electron-${{ hashFiles('**/yarn.lock', 'package.json', 'electron-builder.yml') }}
          restore-keys: |
            ${{ runner.os }}-node20-electron-

      - name: Install Dependencies
        run: yarn install

      - name: Build app bundles
        run: yarn build

      - name: Package ${{ matrix.edition }} edition
        shell: pwsh
        run: |
          $outDir = Join-Path $env:RUNNER_TEMP "release-${{ matrix.edition }}"
          Remove-Item -Recurse -Force -Path $outDir -ErrorAction SilentlyContinue

          $env:APP_EDITION = "${{ matrix.edition }}"
          $env:BUILD_VOICE = "${{ matrix.voice }}"
          Remove-Item Env:BUILD_SUFFIX -ErrorAction SilentlyContinue
          yarn run electron-builder --win --x64 --publish never --config.directories.output="$outDir"

      - name: Collect ${{ matrix.edition }} installer
        shell: pwsh
        run: |
          $version = "${{ needs.prepare.outputs.version }}"
          New-Item -ItemType Directory -Force -Path artifacts | Out-Null

          $setup = Join-Path (Join-Path $env:RUNNER_TEMP "release-${{ matrix.edition }}") "gist-$version-x64-setup.exe"
          if (-not (Test-Path $setup)) {
            throw "Installer not found: $setup"
          }

          Get-Item $setup | Select-Object Name, Length | Format-Table -AutoSize

          Copy-Item -Path $setup -Destination "artifacts/gist-$version-x64-setup-${{ matrix.edition }}.exe" -Force

      - name: Upload ${{ matrix.edition }} installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: installer-${{ matrix.edition }}
          path: artifacts/*.exe
          if-no-files-found: error
          retention-days: 7

  publish:
    needs:
      - prepare
      - package-windows
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Set package.json version
        shell: bash
        run: |
          npm version "${{ needs.prepare.outputs.version }}" --no-git-tag-version --allow-same-version

      - name: Generate release notes
        shell: bash
        run: |
          set -euo pipefail

          PREV_TAG="v${{ needs.prepare.outputs.base }}"
          FROM_ARG=()
          if git rev-parse -q --verify "refs/tags/${PREV_TAG}" >/dev/null; then
            FROM_ARG=(--from "${PREV_TAG}")
          fi

          node scripts/generate-release-notes.js \
            "${FROM_ARG[@]}" \
            --to HEAD \
            --version "${{ needs.prepare.outputs.tag }}" \
            --repo "${{ github.repository }}" > release-notes.md

          echo "Generated release notes:"
          cat release-notes.md

      - name: Download pro installer artifact
        uses: actions/download-artifact@v4
        with:
          name: installer-pro
          path: artifacts

      - name: Download basic installer artifact
        uses: actions/download-artifact@v4
        with:
          name: installer-basic
          path: artifacts

      - name: List artifacts
        shell: bash
        run: |
          ls -lah artifacts

      - name: Commit version and push tag
        shell: bash
        run: |
          set -euo pipefail

          TAG="${{ needs.prepare.outputs.tag }}"

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git add package.json
          if ! git diff --cached --quiet; then
            git commit --signoff -m "ci(release): bump version to ${TAG} [skip ci]"
            git push origin "HEAD:${{ github.ref_name }}"
          else
            echo "No package.json version change to commit."
          fi

          if ! git rev-parse -q --verify "refs/tags/${TAG}" >/dev/null; then
            git tag "${TAG}"
          fi

          if ! git ls-remote --exit-code --tags origin "${TAG}" >/dev/null 2>&1; then
            git push origin "${TAG}"
          else
            echo "Tag ${TAG} already exists on origin."
          fi

      - name: Validate public release token
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${{ secrets.DOWNLOADS_REPO_TOKEN }}" ]; then
            echo "::error::Missing secret DOWNLOADS_REPO_TOKEN."
            echo "Please add a fine-grained PAT with access to motto1/gist-downloads (Contents: Read and write)."
            exit 1
          fi

      - name: Publish assets to public downloads repository
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.DOWNLOADS_REPO_TOKEN }}
          TARGET_REPO: motto1/gist-downloads
        run: |
          set -euo pipefail

          TAG="${{ needs.prepare.outputs.tag }}"
          TITLE="Release ${TAG}"

          if gh release view "$TAG" --repo "$TARGET_REPO" >/dev/null 2>&1; then
            gh release edit "$TAG" \
              --repo "$TARGET_REPO" \
              --title "$TITLE" \
              --notes-file release-notes.md
          else
            gh release create "$TAG" \
              --repo "$TARGET_REPO" \
              --title "$TITLE" \
              --notes-file release-notes.md
          fi

          gh release upload "$TAG" artifacts/*.exe \
            --repo "$TARGET_REPO" \
            --clobber

  publish-gitee:
    needs:
      - prepare
      - package-windows
      - publish
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Install Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Generate release notes
        shell: bash
        run: |
          set -euo pipefail

          PREV_TAG="v${{ needs.prepare.outputs.base }}"
          FROM_ARG=()
          if git rev-parse -q --verify "refs/tags/${PREV_TAG}" >/dev/null; then
            FROM_ARG=(--from "${PREV_TAG}")
          fi

          node scripts/generate-release-notes.js \
            "${FROM_ARG[@]}" \
            --to HEAD \
            --version "${{ needs.prepare.outputs.tag }}" \
            --repo "${{ github.repository }}" > release-notes.md

      - name: Download pro installer artifact
        uses: actions/download-artifact@v4
        with:
          name: installer-pro
          path: artifacts

      - name: Download basic installer artifact
        uses: actions/download-artifact@v4
        with:
          name: installer-basic
          path: artifacts

      - name: Validate Gitee settings
        shell: bash
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
          GITEE_RELEASE_REPO: ${{ vars.GITEE_RELEASE_REPO }}
        run: |
          set -euo pipefail

          if [ -z "${GITEE_TOKEN}" ]; then
            echo "::error::Missing secret GITEE_TOKEN"
            echo "Please create GITEE_TOKEN with Releases read/write permissions."
            exit 1
          fi

          if [ -z "${GITEE_RELEASE_REPO}" ] || [[ "${GITEE_RELEASE_REPO}" != */* ]]; then
            echo "::error::Missing vars.GITEE_RELEASE_REPO (format: owner/repo)"
            exit 1
          fi

      - name: Sync release to Gitee
        shell: bash
        env:
          GITEE_TOKEN: ${{ secrets.GITEE_TOKEN }}
          GITEE_RELEASE_REPO: ${{ vars.GITEE_RELEASE_REPO }}
        run: |
          set -euo pipefail

          TAG="${{ needs.prepare.outputs.tag }}"
          TITLE="Release ${TAG}"
          BODY="$(cat release-notes.md)"

          OWNER="${GITEE_RELEASE_REPO%%/*}"
          REPO="${GITEE_RELEASE_REPO#*/}"
          API_BASE="https://gitee.com/api/v5/repos/${OWNER}/${REPO}"

          echo "Syncing ${TAG} to Gitee repo: ${OWNER}/${REPO}"

          TARGET_COMMITISH=$(curl -sS -G "${API_BASE}" \
            --data-urlencode "access_token=${GITEE_TOKEN}" | jq -r '.default_branch // empty')

          if [ -z "${TARGET_COMMITISH}" ]; then
            TARGET_COMMITISH=$(curl -sS -G "${API_BASE}/branches" \
              --data-urlencode "access_token=${GITEE_TOKEN}" | jq -r '.[0].name // empty')
          fi

          if [ -z "${TARGET_COMMITISH}" ]; then
            echo "::error::Gitee repo has no branch. Please initialize ${OWNER}/${REPO} with at least one commit (main/master)."
            exit 1
          fi

          RELEASE_ID=$(curl -sS -G "${API_BASE}/releases/tags/${TAG}" \
            --data-urlencode "access_token=${GITEE_TOKEN}" | jq -r '.id // empty')

          if [ -n "${RELEASE_ID}" ]; then
            echo "Release exists on Gitee (id=${RELEASE_ID}), updating metadata"
            curl -sS -X PATCH "${API_BASE}/releases/${RELEASE_ID}" \
              --data-urlencode "access_token=${GITEE_TOKEN}" \
              --data-urlencode "name=${TITLE}" \
              --data-urlencode "body=${BODY}" > gitee-release.json
          else
            echo "Release does not exist on Gitee, creating"
            curl -sS -X POST "${API_BASE}/releases" \
              --data-urlencode "access_token=${GITEE_TOKEN}" \
              --data-urlencode "tag_name=${TAG}" \
              --data-urlencode "target_commitish=${TARGET_COMMITISH}" \
              --data-urlencode "name=${TITLE}" \
              --data-urlencode "body=${BODY}" > gitee-release.json
          fi

          RELEASE_ID=$(jq -r '.id // empty' gitee-release.json)
          if [ -z "${RELEASE_ID}" ]; then
            echo "::error::Failed to resolve Gitee release id"
            cat gitee-release.json
            exit 1
          fi

          echo "Gitee release id: ${RELEASE_ID}"

          RELEASE_DETAIL=$(curl -sS -G "${API_BASE}/releases/${RELEASE_ID}" \
            --data-urlencode "access_token=${GITEE_TOKEN}")

          for file in artifacts/*.exe; do
            name="$(basename "$file")"
            echo "Uploading $name"

            existing_id=$(printf '%s' "$RELEASE_DETAIL" | jq -r --arg name "$name" '.assets[]? | select(.name == $name) | .id' | head -n 1)
            if [ -n "${existing_id}" ]; then
              echo "Deleting existing asset: ${name} (id=${existing_id})"
              curl -sS -X DELETE "${API_BASE}/releases/${RELEASE_ID}/attach_files/${existing_id}" \
                --data-urlencode "access_token=${GITEE_TOKEN}" >/dev/null || true
            fi

            curl -sS -X POST "${API_BASE}/releases/${RELEASE_ID}/attach_files" \
              -F "access_token=${GITEE_TOKEN}" \
              -F "file=@${file}" >/dev/null
          done

          echo "Gitee release sync completed: ${OWNER}/${REPO} ${TAG}"
